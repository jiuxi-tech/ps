# 支持账号兼职导入功能总结

## 一、需求背景

**用户反馈**：
```json
{
    "errors": [
        {
            "row": 5,
            "field": "账号名",
            "value": "imp006",
            "message": "账号名在本次导入中重复"
        },
        {
            "row": 6,
            "field": "账号名",
            "value": "imp006",
            "message": "账号名在本次导入中重复"
        }
    ]
}
```

**需求说明**：
> 如果是兼职，应该允许账号名在本次导入中重复。
> - 如本例中 `imp006`，当系统中已存在 `imp006`，则模板中的 `imp006` 都为兼职
> - 如系统中没有 `imp006`，但模板中多次出现 `imp006`，那第一次出现的 `imp006` 为主部门，其余的为兼职

## 二、问题分析

### 原有逻辑

在 `validateUsernameUniqueness` 方法中（第239-241行）：

```java
// 检查本次导入数据中是否重复
if (cache.contains(username)) {
    errors.add(new ImportErrorDTO(row, "账号名", username, "账号名在本次导入中重复"));
    return;
}
```

**存在的问题**：
- ❌ 不允许同一账号名在一次导入中出现多次
- ❌ 无法支持兼职场景（一个人在多个部门）
- ❌ 导致正常的兼职数据被误判为错误

### 实际业务需求

**兼职场景**是人员管理的常见需求：
1. **已有用户添加兼职**：系统中已存在账号 `zhangsan`，导入时在多个部门中都有 `zhangsan`，应该为该用户添加兼职部门
2. **新用户多部门**：系统中不存在账号 `lisi`，导入时在多个部门中都有 `lisi`，应该创建用户并设置主部门和兼职部门

## 三、修改内容

### 文件路径
`d:\projects\ps\ps-be\src\main\java\com\jiuxi\module\user\app\impl\UserImportExportServiceImpl.java`

### 修改的方法
`validateUsernameUniqueness` - 账号唯一性校验

### 修改前

```java
/**
 * 账号唯一性校验
 */
private void validateUsernameUniqueness(UserImportDTO dto, String tenantId,
                                        Set<String> cache, List<ImportErrorDTO> errors) {
    String username = dto.getUsername().trim();
    Integer row = dto.getRowNumber();

    // 检查本次导入数据中是否重复
    if (cache.contains(username)) {
        errors.add(new ImportErrorDTO(row, "账号名", username, "账号名在本次导入中重复"));
        return;
    }

    // 检查数据库中是否已存在
    TpAccount existingAccount = tpAccountMapper.selectByUsername(username);
    if (existingAccount != null && existingAccount.getActived() == 1) {
        // 账号已存在，标记为兼职导入（不报错，后续作为兼职处理）
        logger.debug("账号{}已存在，将作为兼职部门导入", username);
    }

    cache.add(username);
}
```

### 修改后

```java
/**
 * 账号唯一性校验
 * 注意：允许同一账号在本次导入中多次出现（处理为兼职）
 * - 如果系统中已存在，则本次导入的所有记录都作为兼职部门
 * - 如果系统中不存在，第一次出现作为主部门，其余作为兼职部门
 */
private void validateUsernameUniqueness(UserImportDTO dto, String tenantId,
                                        Set<String> cache, List<ImportErrorDTO> errors) {
    String username = dto.getUsername().trim();
    Integer row = dto.getRowNumber();

    // 注释原有的重复检查逻辑，允许账号名在本次导入中重复（用于兼职场景）
    // if (cache.contains(username)) {
    //     errors.add(new ImportErrorDTO(row, "账号名", username, "账号名在本次导入中重复"));
    //     return;
    // }

    // 检查数据库中是否已存在
    TpAccount existingAccount = tpAccountMapper.selectByUsername(username);
    if (existingAccount != null && existingAccount.getActived() == 1) {
        // 账号已存在，标记为兼职导入（不报错，后续作为兼职处理）
        logger.debug("账号{}已存在，将作为兼职部门导入", username);
    }

    cache.add(username);
}
```

## 四、功能说明

### 1. 兼职场景处理逻辑

已有的 `importDataToDB` 方法（第318-340行）已经实现了完善的兼职处理逻辑：

```java
// 按账号分组（同一账号的多条数据表示兼职）
Map<String, List<UserImportDTO>> userGroups = dataList.stream()
    .collect(Collectors.groupingBy(dto -> dto.getUsername().trim()));

for (Map.Entry<String, List<UserImportDTO>> entry : userGroups.entrySet()) {
    String username = entry.getKey();
    List<UserImportDTO> userDataList = entry.getValue();

    // 检查账号是否已存在
    TpAccount existingAccount = tpAccountMapper.selectByUsername(username);
    
    if (existingAccount == null) {
        // 新用户：创建人员、账号、部门关系
        createNewUser(userDataList, operatorId, tenantId, ascnId, now);
    } else {
        // 已有用户：仅添加兼职部门
        addPartTimeDepts(existingAccount.getPersonId(), userDataList, now);
    }
}
```

### 2. 新用户创建逻辑

`createNewUser` 方法（第345-412行）：
- 使用第一条数据创建人员基本信息和账号
- 第一条数据对应的部门设为主部门（`defaultDept = 1`）
- 其余数据对应的部门设为兼职部门（`defaultDept = 0`）

```java
// 4. 创建人员部门关系（第一个为主部门，其余为兼职部门）
for (int i = 0; i < userDataList.size(); i++) {
    UserImportDTO dto = userDataList.get(i);
    String deptId = getDeptIdByPath(dto.getDeptPath().trim());

    TpPersonDept personDept = new TpPersonDept();
    personDept.setPersonId(personId);
    personDept.setDeptId(deptId);
    personDept.setDefaultDept(i == 0 ? 1 : 0); // 第一个为主部门
    
    tpPersonDeptMapper.save(personDept);
}
```

### 3. 已有用户兼职添加逻辑

`addPartTimeDepts` 方法（第417-431行）：
- 为已存在的用户添加兼职部门
- 所有导入的部门都设为兼职部门（`defaultDept = 0`）

```java
private void addPartTimeDepts(String personId, List<UserImportDTO> userDataList, String now) {
    for (UserImportDTO dto : userDataList) {
        String deptId = getDeptIdByPath(dto.getDeptPath().trim());

        TpPersonDept personDept = new TpPersonDept();
        personDept.setPersonId(personId);
        personDept.setDeptId(deptId);
        personDept.setDefaultDept(0); // 所有导入的都是兼职部门
        
        tpPersonDeptMapper.save(personDept);
    }
}
```

## 五、业务场景示例

### 场景1：新用户多部门

**Excel 模板数据**：
| 账号名 | 姓名 | 部门 |
|--------|------|------|
| zhangsan | 张三 | 办公室 |
| zhangsan | 张三 | 财务部 |
| zhangsan | 张三 | 人事部 |

**处理结果**：
1. ✅ 创建账号 `zhangsan`，人员信息为"张三"
2. ✅ "办公室"为主部门（`defaultDept = 1`）
3. ✅ "财务部"为兼职部门（`defaultDept = 0`）
4. ✅ "人事部"为兼职部门（`defaultDept = 0`）

### 场景2：已有用户添加兼职

**系统中已存在**：
- 账号：`lisi`
- 姓名：李四
- 主部门：技术部

**Excel 模板数据**：
| 账号名 | 姓名 | 部门 |
|--------|------|------|
| lisi | 李四 | 市场部 |
| lisi | 李四 | 销售部 |

**处理结果**：
1. ✅ 不创建新账号，使用已有账号 `lisi`
2. ✅ 保留原有主部门"技术部"
3. ✅ "市场部"添加为兼职部门（`defaultDept = 0`）
4. ✅ "销售部"添加为兼职部门（`defaultDept = 0`）

### 场景3：混合场景

**Excel 模板数据**：
| 账号名 | 姓名 | 部门 |
|--------|------|------|
| zhangsan | 张三 | 办公室 |
| zhangsan | 张三 | 财务部 |
| lisi | 李四 | 市场部 |
| wangwu | 王五 | 技术部 |

**处理结果**：
1. ✅ `zhangsan`（新用户）：主部门"办公室"，兼职"财务部"
2. ✅ `lisi`（已有用户）：添加兼职部门"市场部"
3. ✅ `wangwu`（新用户）：主部门"技术部"

## 六、其他校验保留

虽然允许账号名重复，但以下校验仍然保留：

### 1. 兼职重复性校验

`validatePartTimeDuplication` 方法确保：
- ❌ 同一账号不能在同一部门重复兼职
- ❌ 导入的部门不能与该账号已有的部门重复

**示例错误**：
```
账号[zhangsan]在部门[办公室]重复兼职
账号[zhangsan]已在部门[财务部]中
```

### 2. 身份证号唯一性校验

`validateIdcardUniqueness` 方法确保：
- ❌ 身份证号在本次导入中不能重复
- ❌ 身份证号在数据库中不能重复

### 3. 其他基础校验

- ✅ 必填字段校验（账号名、密码、姓名、部门）
- ✅ 格式校验（参加工作时间、身份证号等）
- ✅ 部门存在性校验
- ✅ 部门有效性校验

## 七、测试建议

### 1. 正常场景测试

- [ ] 新用户单部门导入
- [ ] 新用户多部门导入（主部门+兼职）
- [ ] 已有用户添加兼职部门
- [ ] 混合导入（新用户+已有用户）

### 2. 边界场景测试

- [ ] 同一账号在10个部门（大量兼职）
- [ ] 100个不同账号，每个账号都有兼职
- [ ] 账号在模板中重复，但部门相同（应报错）
- [ ] 账号在模板中重复，且部门与数据库重复（应报错）

### 3. 错误场景测试

- [ ] 账号名重复+部门重复：应报错"账号[xxx]在部门[xxx]重复兼职"
- [ ] 账号名重复+部门与数据库重复：应报错"账号[xxx]已在部门[xxx]中"
- [ ] 其他字段错误（姓名为空、部门不存在等）

## 八、注意事项

1. **数据一致性**：虽然允许账号名重复，但每条记录的基本信息（姓名、性别、身份证号等）应该一致
2. **部门唯一性**：同一账号在同一部门不能重复，无论是本次导入还是已有数据
3. **主部门优先级**：新用户导入时，第一条记录对应的部门自动设为主部门
4. **兼职限制**：建议设置兼职部门数量上限（如不超过10个），避免数据异常

## 九、后续优化建议

1. **导入预览功能**：在正式导入前，显示哪些是新用户、哪些是兼职添加
2. **兼职数量限制**：在校验阶段检查兼职数量，超过限制时提示警告
3. **基本信息一致性检查**：当同一账号多次出现时，检查姓名、身份证号等是否一致
4. **主部门调整**：允许在导入时指定主部门，而不是默认第一条记录

---

**修改日期**: 2025-11-28  
**修改人**: AI Assistant  
**影响范围**: 用户导入功能 - 兼职场景支持
