# PS-BE Module模块重构测试详细指南

## 文档概述

本测试指南与《模块细粒度的优化计划.md》相对应，为每个重构阶段提供详细的测试策略、测试用例设计和自动化测试脚本指导。确保重构过程中功能稳定性和代码质量。

## 测试原则与策略

### 核心测试原则

1. **功能回归零容忍**：任何重构都不能破坏现有功能
2. **测试先行**：重构前编写测试，重构后验证通过
3. **分层测试**：单元测试、集成测试、接口测试全覆盖
4. **自动化优先**：所有测试用例都要支持自动化执行
5. **持续验证**：每个提交都要通过完整的测试套件

### 测试分层策略

```
测试金字塔结构：
├── E2E测试 (10%) - 端到端业务流程测试
├── 集成测试 (20%) - 模块间协作测试
├── 接口测试 (30%) - API层测试
└── 单元测试 (40%) - 领域模型和业务逻辑测试
```

## 第一阶段：模块整合测试（第1-2周）

### 1.1 重复模块整合测试

#### 1.1.1 System模块整合测试

**测试目标：**
- 验证system模块功能完全迁移到sys模块
- 确保新旧接口都能正常工作
- 验证数据一致性

**测试用例设计：**

```java
// 示例测试类结构
@TestMethodOrder(OrderAnnotation.class)
@SpringBootTest
class SystemModuleIntegrationTest {
    
    @Test
    @Order(1)
    void testLegacySystemConfigService() {
        // 测试旧的TpSystemConfig相关接口
    }
    
    @Test
    @Order(2)
    void testNewSystemConfigService() {
        // 测试新的SystemConfig相关接口
    }
    
    @Test
    @Order(3)
    void testDataConsistency() {
        // 验证新旧接口操作同一数据的一致性
    }
    
    @Test
    @Order(4)
    void testAdapterPattern() {
        // 测试适配器模式的正确性
    }
}
```

**自动化测试脚本指导：**

1. **数据对比测试脚本**
   ```bash
   # 脚本名称：compare_system_config_data.sh
   # 功能：对比新旧接口的数据一致性
   
   echo "开始系统配置数据一致性测试..."
   
   # 通过旧接口获取配置列表
   OLD_API_RESULT=$(curl -s http://localhost:8080/api/legacy/system/config/list)
   
   # 通过新接口获取配置列表
   NEW_API_RESULT=$(curl -s http://localhost:8080/api/sys/config/list)
   
   # 对比结果数量
   OLD_COUNT=$(echo $OLD_API_RESULT | jq '.data | length')
   NEW_COUNT=$(echo $NEW_API_RESULT | jq '.data | length')
   
   if [ "$OLD_COUNT" -eq "$NEW_COUNT" ]; then
       echo "✅ 数据数量一致: $OLD_COUNT"
   else
       echo "❌ 数据数量不一致: 旧接口 $OLD_COUNT, 新接口 $NEW_COUNT"
       exit 1
   fi
   
   echo "系统配置数据一致性测试完成"
   ```

2. **功能回归测试脚本**
   ```bash
   # 脚本名称：system_module_regression_test.sh
   # 功能：验证系统配置模块所有功能正常
   
   echo "开始系统配置模块回归测试..."
   
   # 测试配置查询功能
   CONFIG_QUERY_RESULT=$(curl -s -o /dev/null -w "%{http_code}" \
       http://localhost:8080/api/sys/config/get?key=test.config)
   
   if [ "$CONFIG_QUERY_RESULT" -eq 200 ]; then
       echo "✅ 配置查询功能正常"
   else
       echo "❌ 配置查询功能异常: HTTP $CONFIG_QUERY_RESULT"
       exit 1
   fi
   
   # 测试配置更新功能
   UPDATE_RESULT=$(curl -s -X PUT \
       -H "Content-Type: application/json" \
       -d '{"configKey":"test.config","configValue":"test_value","configName":"测试配置"}' \
       -o /dev/null -w "%{http_code}" \
       http://localhost:8080/api/sys/config/update)
   
   if [ "$UPDATE_RESULT" -eq 200 ]; then
       echo "✅ 配置更新功能正常"
   else
       echo "❌ 配置更新功能异常: HTTP $UPDATE_RESULT"
       exit 1
   fi
   
   echo "系统配置模块回归测试完成"
   ```

#### 1.1.2 Organization模块整合测试

**测试目标：**
- 验证organization模块功能迁移到org模块
- 测试部门、企业管理功能完整性
- 验证组织架构层级关系正确性

**测试用例设计：**

```java
@SpringBootTest
class OrganizationModuleIntegrationTest {
    
    @Test
    void testDepartmentHierarchy() {
        // 测试部门层级结构
        // 1. 创建父部门
        // 2. 创建子部门
        // 3. 验证层级关系
        // 4. 验证查询结果
    }
    
    @Test
    void testEnterpriseManagement() {
        // 测试企业管理功能
        // 1. 创建企业
        // 2. 更新企业信息
        // 3. 查询企业详情
        // 4. 删除企业
    }
    
    @Test
    void testCrossModuleIntegration() {
        // 测试跨模块集成
        // 组织变更 → 用户模块同步
        // 组织变更 → 权限模块同步
    }
}
```

#### 1.1.3 Authorization模块整合测试

**测试目标：**
- 验证authorization模块功能迁移到auth模块
- 测试权限控制完整性
- 验证角色权限分配正确性

**测试用例设计：**

```java
@SpringBootTest
class AuthorizationModuleIntegrationTest {
    
    @Test
    void testRolePermissionBinding() {
        // 测试角色权限绑定
        // 1. 创建角色
        // 2. 分配权限
        // 3. 验证权限生效
        // 4. 测试权限撤销
    }
    
    @Test
    void testMenuPermissionControl() {
        // 测试菜单权限控制
        // 1. 配置菜单权限
        // 2. 用户登录验证
        // 3. 菜单访问测试
        // 4. 权限变更验证
    }
}
```

### 1.2 适配器层测试

#### 1.2.1 适配器功能测试

**测试目标：**
- 验证适配器正确转换新旧数据格式
- 测试适配器异常处理
- 验证性能无明显下降

**自动化测试脚本：**

```bash
# 脚本名称：adapter_performance_test.sh
# 功能：测试适配器层性能

echo "开始适配器性能测试..."

# 记录开始时间
START_TIME=$(date +%s%N)

# 批量调用适配器接口
for i in {1..100}; do
    curl -s http://localhost:8080/api/adapter/system/config/list > /dev/null
done

# 记录结束时间
END_TIME=$(date +%s%N)

# 计算耗时（毫秒）
DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
AVG_TIME=$(( DURATION / 100 ))

echo "适配器平均响应时间: ${AVG_TIME}ms"

if [ "$AVG_TIME" -lt 100 ]; then
    echo "✅ 适配器性能测试通过"
else
    echo "❌ 适配器性能测试失败，平均响应时间过长"
    exit 1
fi
```

## 第二阶段：核心模块重构测试（第3-6周）

### 2.1 用户模块重构测试

#### 2.1.1 领域模型测试

**测试目标：**
- 验证User聚合根拆分后功能正确
- 测试值对象验证逻辑
- 验证领域事件发布机制

**测试用例设计：**

```java
@ExtendWith(MockitoExtension.class)
class UserDomainModelTest {
    
    @Test
    void testUserAggregateCreation() {
        // 测试用户聚合根创建
        UserProfile profile = new UserProfile("张三", "男", LocalDate.of(1990, 1, 1));
        User user = User.create("user123", profile, UserCategory.INDIVIDUAL, "admin", "tenant1");
        
        assertThat(user.getPersonId()).isEqualTo("user123");
        assertThat(user.getProfile().getPersonName()).isEqualTo("张三");
        assertThat(user.getStatus()).isEqualTo(UserStatus.ACTIVE);
        assertThat(user.hasDomainEvents()).isTrue();
    }
    
    @Test
    void testUserAccountCreation() {
        // 测试用户账户创建
        User user = createTestUser();
        user.createAccount("testuser", "password123", "admin");
        
        assertThat(user.hasAccount()).isTrue();
        assertThat(user.getAccount().getUsername()).isEqualTo("testuser");
        assertThat(user.getDomainEvents()).hasSize(2); // 用户创建 + 账户创建事件
    }
    
    @Test
    void testValueObjectValidation() {
        // 测试值对象验证
        assertThatThrownBy(() -> new Email("invalid-email"))
            .isInstanceOf(IllegalArgumentException.class);
            
        assertThatThrownBy(() -> new PhoneNumber("123"))
            .isInstanceOf(IllegalArgumentException.class);
    }
    
    @Test
    void testDomainEventPublishing() {
        // 测试领域事件发布
        User user = createTestUser();
        List<UserEvent> events = user.getDomainEvents();
        
        assertThat(events).hasSize(1);
        assertThat(events.get(0)).isInstanceOf(UserCreatedEvent.class);
        
        UserCreatedEvent event = (UserCreatedEvent) events.get(0);
        assertThat(event.getPersonId()).isEqualTo(user.getPersonId());
    }
}
```

#### 2.1.2 应用服务测试

**测试目标：**
- 验证应用服务事务边界
- 测试业务规则验证
- 验证异常处理机制

**测试用例设计：**

```java
@SpringBootTest
@Transactional
class UserApplicationServiceTest {
    
    @Autowired
    private UserApplicationService userApplicationService;
    
    @MockBean
    private UserRepository userRepository;
    
    @Test
    void testCreateUserWithValidData() {
        // 测试正常用户创建流程
        UserCreateDTO createDTO = new UserCreateDTO();
        createDTO.setPersonName("张三");
        createDTO.setGender("男");
        createDTO.setBirthDate(LocalDate.of(1990, 1, 1));
        createDTO.setEmail("zhangsan@example.com");
        createDTO.setPhoneNumber("13800138000");
        
        when(userRepository.save(any(User.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        
        UserResponseDTO result = userApplicationService.createUser(createDTO, "admin", "tenant1");
        
        assertThat(result).isNotNull();
        assertThat(result.getPersonName()).isEqualTo("张三");
        verify(userRepository).save(any(User.class));
    }
    
    @Test
    void testCreateUserWithDuplicateEmail() {
        // 测试邮箱重复的异常处理
        UserCreateDTO createDTO = new UserCreateDTO();
        createDTO.setEmail("existing@example.com");
        
        when(userRepository.existsByEmail("existing@example.com"))
            .thenReturn(true);
        
        assertThatThrownBy(() -> 
            userApplicationService.createUser(createDTO, "admin", "tenant1"))
            .isInstanceOf(BusinessException.class)
            .hasMessage("邮箱已存在");
    }
    
    @Test
    @Rollback
    void testTransactionRollback() {
        // 测试事务回滚机制
        UserCreateDTO createDTO = createValidUserDTO();
        
        when(userRepository.save(any(User.class)))
            .thenThrow(new RuntimeException("数据库异常"));
        
        assertThatThrownBy(() -> 
            userApplicationService.createUser(createDTO, "admin", "tenant1"))
            .isInstanceOf(RuntimeException.class);
        
        // 验证事务回滚后数据库状态
        assertThat(userRepository.count()).isZero();
    }
}
```

#### 2.1.3 仓储层测试

**测试目标：**
- 验证数据持久化正确性
- 测试查询方法准确性
- 验证数据转换无误

**测试用例设计：**

```java
@DataJpaTest
class UserRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private UserRepositoryImpl userRepository;
    
    @Test
    void testSaveAndFindUser() {
        // 测试用户保存和查询
        User user = createTestUser();
        User savedUser = userRepository.save(user);
        
        Optional<User> foundUser = userRepository.findById(savedUser.getPersonId());
        
        assertThat(foundUser).isPresent();
        assertThat(foundUser.get().getPersonId()).isEqualTo(savedUser.getPersonId());
        assertThat(foundUser.get().getProfile().getPersonName())
            .isEqualTo(savedUser.getProfile().getPersonName());
    }
    
    @Test
    void testFindByEmail() {
        // 测试按邮箱查询
        User user = createTestUser();
        user.getContactInfo().setEmail(new Email("test@example.com"));
        entityManager.persistAndFlush(convertToPO(user));
        
        Optional<User> result = userRepository.findByEmail("test@example.com");
        
        assertThat(result).isPresent();
        assertThat(result.get().getContactInfo().getEmail().getValue())
            .isEqualTo("test@example.com");
    }
    
    @Test
    void testComplexQuery() {
        // 测试复杂查询
        // 创建多个测试用户
        List<User> users = createMultipleTestUsers();
        users.forEach(user -> entityManager.persistAndFlush(convertToPO(user)));
        
        // 按条件查询
        List<User> activeUsers = userRepository.findByStatusAndTenant(
            UserStatus.ACTIVE, "tenant1");
        
        assertThat(activeUsers).hasSize(2);
        assertThat(activeUsers).allMatch(user -> user.isActive());
    }
}
```

### 2.2 权限模块重构测试

#### 2.2.1 RBAC模型测试

**测试目标：**
- 验证角色权限分配机制
- 测试权限继承逻辑
- 验证数据权限控制

**测试用例设计：**

```java
@SpringBootTest
class RBACModelTest {
    
    @Test
    void testRolePermissionAssignment() {
        // 测试角色权限分配
        Role adminRole = new Role("ADMIN", "管理员", RoleType.SYSTEM);
        Permission userManagePermission = new Permission(
            "USER_MANAGE", "用户管理", PermissionType.OPERATION);
        
        adminRole.assignPermission(userManagePermission);
        
        assertThat(adminRole.hasPermission("USER_MANAGE")).isTrue();
        assertThat(adminRole.getPermissions()).contains(userManagePermission);
    }
    
    @Test
    void testDataPermissionControl() {
        // 测试数据权限控制
        Role deptManagerRole = new Role("DEPT_MANAGER", "部门经理", RoleType.BUSINESS);
        DataPermission dataPermission = new DataPermission(
            DataScope.DEPARTMENT, "dept123");
        
        deptManagerRole.assignDataPermission(dataPermission);
        
        assertThat(deptManagerRole.canAccessData("dept123")).isTrue();
        assertThat(deptManagerRole.canAccessData("dept456")).isFalse();
    }
    
    @Test
    void testPermissionInheritance() {
        // 测试权限继承
        Role parentRole = new Role("PARENT", "父角色", RoleType.SYSTEM);
        Role childRole = new Role("CHILD", "子角色", RoleType.BUSINESS);
        
        Permission permission = new Permission("TEST_PERM", "测试权限", PermissionType.OPERATION);
        parentRole.assignPermission(permission);
        childRole.setParentRole(parentRole);
        
        assertThat(childRole.hasEffectivePermission("TEST_PERM")).isTrue();
    }
}
```

#### 2.2.2 权限缓存测试

**测试目标：**
- 验证权限缓存机制
- 测试缓存更新策略
- 验证缓存一致性

**测试用例设计：**

```java
@SpringBootTest
class PermissionCacheTest {
    
    @Autowired
    private PermissionCacheService permissionCacheService;
    
    @Test
    void testPermissionCaching() {
        // 测试权限缓存
        String userId = "user123";
        Set<String> permissions = Set.of("USER_READ", "USER_WRITE");
        
        // 缓存权限
        permissionCacheService.cacheUserPermissions(userId, permissions);
        
        // 验证缓存命中
        Optional<Set<String>> cachedPermissions = 
            permissionCacheService.getUserPermissions(userId);
        
        assertThat(cachedPermissions).isPresent();
        assertThat(cachedPermissions.get()).containsExactlyInAnyOrderElementsOf(permissions);
    }
    
    @Test
    void testCacheInvalidation() {
        // 测试缓存失效
        String userId = "user123";
        permissionCacheService.cacheUserPermissions(userId, Set.of("USER_READ"));
        
        // 用户权限变更，清除缓存
        permissionCacheService.evictUserPermissions(userId);
        
        Optional<Set<String>> cachedPermissions = 
            permissionCacheService.getUserPermissions(userId);
        
        assertThat(cachedPermissions).isEmpty();
    }
}
```

### 2.3 系统配置模块重构测试

#### 2.3.1 配置管理测试

**测试目标：**
- 验证配置热更新机制
- 测试配置验证框架
- 验证配置分组管理

**测试用例设计：**

```java
@SpringBootTest
class SystemConfigManagementTest {
    
    @Test
    void testConfigHotReload() {
        // 测试配置热更新
        String configKey = "test.hot.reload";
        String oldValue = "old_value";
        String newValue = "new_value";
        
        // 设置初始配置
        systemConfigService.setConfigValue(configKey, oldValue);
        assertThat(systemConfigService.getConfigValue(configKey)).isEqualTo(oldValue);
        
        // 更新配置并触发热更新
        systemConfigService.updateConfigValue(configKey, newValue);
        systemConfigService.triggerHotReload(configKey);
        
        // 验证配置已更新
        assertThat(systemConfigService.getConfigValue(configKey)).isEqualTo(newValue);
    }
    
    @Test
    void testConfigValidation() {
        // 测试配置验证
        SystemConfigCreateDTO invalidConfig = new SystemConfigCreateDTO();
        invalidConfig.setConfigKey(""); // 空键值
        invalidConfig.setConfigValue("invalid_json{"); // 无效JSON
        invalidConfig.setDataType("JSON");
        
        assertThatThrownBy(() -> 
            systemConfigService.createSystemConfig(invalidConfig, "admin"))
            .isInstanceOf(ValidationException.class);
    }
    
    @Test
    void testConfigGrouping() {
        // 测试配置分组
        // 创建不同组的配置
        createConfigInGroup("database", "db.host", "localhost");
        createConfigInGroup("database", "db.port", "3306");
        createConfigInGroup("cache", "cache.ttl", "300");
        
        // 按组查询配置
        List<SystemConfig> dbConfigs = 
            systemConfigService.getConfigsByGroup("database");
        List<SystemConfig> cacheConfigs = 
            systemConfigService.getConfigsByGroup("cache");
        
        assertThat(dbConfigs).hasSize(2);
        assertThat(cacheConfigs).hasSize(1);
    }
}
```

## 第三阶段：模块间协作测试（第7-8周）

### 3.1 事件驱动架构测试

#### 3.1.1 领域事件测试

**测试目标：**
- 验证事件发布机制
- 测试事件处理逻辑
- 验证跨模块事件传播

**测试用例设计：**

```java
@SpringBootTest
class DomainEventTest {
    
    @Autowired
    private DomainEventBus domainEventBus;
    
    @EventListener
    static class TestEventHandler {
        private final List<DomainEvent> handledEvents = new ArrayList<>();
        
        @EventListener
        public void handle(UserCreatedEvent event) {
            handledEvents.add(event);
        }
        
        public List<DomainEvent> getHandledEvents() {
            return handledEvents;
        }
    }
    
    @Test
    void testEventPublishing() {
        // 测试事件发布
        UserCreatedEvent event = new UserCreatedEvent(
            "user123", "张三", UserCategory.INDIVIDUAL, "admin", "tenant1");
        
        domainEventBus.publish(event);
        
        // 等待事件处理
        await().atMost(Duration.ofSeconds(5))
            .until(() -> testEventHandler.getHandledEvents().size() > 0);
        
        assertThat(testEventHandler.getHandledEvents()).hasSize(1);
    }
    
    @Test
    void testCrossModuleEventPropagation() {
        // 测试跨模块事件传播
        // 用户创建 → 权限模块创建默认角色
        UserCreatedEvent userEvent = new UserCreatedEvent(
            "user123", "张三", UserCategory.INDIVIDUAL, "admin", "tenant1");
        
        domainEventBus.publish(userEvent);
        
        // 验证权限模块接收到事件并处理
        await().atMost(Duration.ofSeconds(5))
            .until(() -> roleRepository.findByUserId("user123").isPresent());
        
        Optional<Role> defaultRole = roleRepository.findByUserId("user123");
        assertThat(defaultRole).isPresent();
        assertThat(defaultRole.get().getRoleType()).isEqualTo(RoleType.DEFAULT);
    }
}
```

#### 3.1.2 集成事件测试

**测试目标：**
- 验证模块间集成事件
- 测试事件消息格式
- 验证事件可靠性投递

**自动化测试脚本：**

```bash
# 脚本名称：integration_event_test.sh
# 功能：测试集成事件处理

echo "开始集成事件测试..."

# 发送用户创建事件
USER_CREATE_RESPONSE=$(curl -s -X POST \
    -H "Content-Type: application/json" \
    -d '{
        "personName": "测试用户",
        "email": "test@example.com",
        "deptId": "dept123"
    }' \
    http://localhost:8080/api/user/create)

USER_ID=$(echo $USER_CREATE_RESPONSE | jq -r '.data.personId')

# 等待事件处理
sleep 2

# 验证权限模块是否接收到事件
ROLE_RESPONSE=$(curl -s http://localhost:8080/api/auth/role/user/$USER_ID)
ROLE_COUNT=$(echo $ROLE_RESPONSE | jq '.data | length')

if [ "$ROLE_COUNT" -gt 0 ]; then
    echo "✅ 用户创建事件处理成功，已分配默认角色"
else
    echo "❌ 用户创建事件处理失败，未分配默认角色"
    exit 1
fi

# 验证组织模块是否接收到事件
ORG_RESPONSE=$(curl -s http://localhost:8080/api/org/department/dept123/members)
MEMBER_EXISTS=$(echo $ORG_RESPONSE | jq --arg uid "$USER_ID" '.data[] | select(.personId == $uid) | length')

if [ "$MEMBER_EXISTS" -gt 0 ]; then
    echo "✅ 用户部门关联事件处理成功"
else
    echo "❌ 用户部门关联事件处理失败"
    exit 1
fi

echo "集成事件测试完成"
```

### 3.2 API网关层测试

#### 3.2.1 统一接口测试

**测试目标：**
- 验证API网关路由正确性
- 测试统一错误处理
- 验证响应格式一致性

**测试用例设计：**

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ApiGatewayTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @LocalServerPort
    private int port;
    
    @Test
    void testUnifiedResponseFormat() {
        // 测试统一响应格式
        String url = "http://localhost:" + port + "/api/user/list";
        
        ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
        
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        
        // 验证响应格式
        JsonNode jsonResponse = objectMapper.readTree(response.getBody());
        assertThat(jsonResponse.has("code")).isTrue();
        assertThat(jsonResponse.has("message")).isTrue();
        assertThat(jsonResponse.has("data")).isTrue();
        assertThat(jsonResponse.has("timestamp")).isTrue();
    }
    
    @Test
    void testErrorHandling() {
        // 测试统一错误处理
        String url = "http://localhost:" + port + "/api/user/999999"; // 不存在的用户ID
        
        ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
        
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
        
        JsonNode jsonResponse = objectMapper.readTree(response.getBody());
        assertThat(jsonResponse.get("code").asText()).isEqualTo("USER_NOT_FOUND");
        assertThat(jsonResponse.get("message").asText()).contains("用户不存在");
    }
    
    @Test
    void testCrossModuleRouting() {
        // 测试跨模块路由
        String[] endpoints = {
            "/api/user/profile",
            "/api/auth/permissions",
            "/api/org/departments",
            "/api/sys/configs"
        };
        
        for (String endpoint : endpoints) {
            String url = "http://localhost:" + port + endpoint;
            ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
            
            assertThat(response.getStatusCode().is2xxSuccessful())
                .as("Endpoint %s should be accessible", endpoint)
                .isTrue();
        }
    }
}
```

### 3.3 共享组件测试

#### 3.3.1 通用组件测试

**测试目标：**
- 验证基础实体类功能
- 测试通用工具类
- 验证共享值对象

**测试用例设计：**

```java
class CommonComponentTest {
    
    @Test
    void testBaseEntity() {
        // 测试基础实体类
        TestEntity entity = new TestEntity();
        entity.setCreator("admin");
        entity.setCreateTime(LocalDateTime.now());
        
        assertThat(entity.getCreator()).isEqualTo("admin");
        assertThat(entity.getCreateTime()).isNotNull();
        assertThat(entity.getId()).isNotNull(); // 自动生成ID
    }
    
    @Test
    void testCommonValueObjects() {
        // 测试通用值对象
        Email email = new Email("test@example.com");
        PhoneNumber phone = new PhoneNumber("13800138000");
        
        assertThat(email.getValue()).isEqualTo("test@example.com");
        assertThat(email.getDomain()).isEqualTo("example.com");
        assertThat(phone.getValue()).isEqualTo("13800138000");
        assertThat(phone.getRegion()).isEqualTo("CN");
    }
    
    @Test
    void testUtilityClasses() {
        // 测试工具类
        String result = StringUtils.camelToSnakeCase("userName");
        assertThat(result).isEqualTo("user_name");
        
        boolean isValid = ValidationUtils.isValidEmail("test@example.com");
        assertThat(isValid).isTrue();
        
        LocalDateTime dateTime = DateTimeUtils.parseDateTime("2023-09-13 10:30:00");
        assertThat(dateTime.getYear()).isEqualTo(2023);
    }
}
```

## 第四阶段：测试策略完善（第9-10周）

### 4.1 单元测试完善

#### 4.1.1 测试覆盖率要求

**覆盖率目标：**
- 领域模型：95%以上
- 业务逻辑：90%以上
- 工具类：100%
- 总体覆盖率：80%以上

**自动化测试脚本：**

```bash
# 脚本名称：test_coverage_check.sh
# 功能：检查测试覆盖率

echo "开始测试覆盖率检查..."

# 运行测试并生成覆盖率报告
mvn clean test jacoco:report

# 提取覆盖率数据
COVERAGE_FILE="target/site/jacoco/jacoco.xml"

if [ ! -f "$COVERAGE_FILE" ]; then
    echo "❌ 覆盖率报告文件不存在"
    exit 1
fi

# 解析总体覆盖率
TOTAL_COVERAGE=$(xmllint --xpath "//report/counter[@type='INSTRUCTION']/@missed" $COVERAGE_FILE | cut -d'"' -f2)
TOTAL_COVERED=$(xmllint --xpath "//report/counter[@type='INSTRUCTION']/@covered" $COVERAGE_FILE | cut -d'"' -f2)

COVERAGE_PERCENT=$(echo "scale=2; $TOTAL_COVERED * 100 / ($TOTAL_COVERED + $TOTAL_COVERAGE)" | bc)

echo "总体测试覆盖率: ${COVERAGE_PERCENT}%"

# 检查是否达到要求
if (( $(echo "$COVERAGE_PERCENT >= 80" | bc -l) )); then
    echo "✅ 测试覆盖率达标"
else
    echo "❌ 测试覆盖率不达标，要求80%以上"
    exit 1
fi

# 检查各模块覆盖率
MODULES=("user" "auth" "org" "sys")

for module in "${MODULES[@]}"; do
    MODULE_COVERAGE=$(xmllint --xpath "//package[starts-with(@name,'com.jiuxi.module.$module')]/counter[@type='INSTRUCTION']/@covered" $COVERAGE_FILE | cut -d'"' -f2)
    MODULE_MISSED=$(xmllint --xpath "//package[starts-with(@name,'com.jiuxi.module.$module')]/counter[@type='INSTRUCTION']/@missed" $COVERAGE_FILE | cut -d'"' -f2)
    
    if [ -n "$MODULE_COVERAGE" ] && [ -n "$MODULE_MISSED" ]; then
        MODULE_PERCENT=$(echo "scale=2; $MODULE_COVERAGE * 100 / ($MODULE_COVERAGE + $MODULE_MISSED)" | bc)
        echo "${module}模块覆盖率: ${MODULE_PERCENT}%"
    fi
done

echo "测试覆盖率检查完成"
```

#### 4.1.2 边界条件测试

**测试重点：**
- 空值处理
- 边界值验证
- 异常场景覆盖

**测试用例模板：**

```java
@ParameterizedTest
@ValueSource(strings = {"", " ", "null"})
void testInvalidStringInputs(String input) {
    // 测试无效字符串输入
    String actualInput = "null".equals(input) ? null : input;
    
    assertThatThrownBy(() -> 
        userService.createUser(actualInput, "valid@email.com"))
        .isInstanceOf(IllegalArgumentException.class);
}

@ParameterizedTest
@ValueSource(ints = {-1, 0, 101, Integer.MAX_VALUE})
void testBoundaryValues(int value) {
    // 测试边界值
    if (value < 1 || value > 100) {
        assertThatThrownBy(() -> 
            configService.updatePriority(value))
            .isInstanceOf(IllegalArgumentException.class);
    }
}
```

### 4.2 集成测试实施

#### 4.2.1 数据库集成测试

**测试目标：**
- 验证数据持久化正确性
- 测试事务管理机制
- 验证数据一致性约束

**测试环境配置：**

```yaml
# application-test.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
  test:
    database:
      replace: none
```

**测试用例设计：**

```java
@SpringBootTest
@Testcontainers
@Transactional
class DatabaseIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Test
    void testCrossTableTransaction() {
        // 测试跨表事务
        assertThatCode(() -> {
            // 创建用户
            User user = userService.createUser(createUserDTO());
            
            // 分配角色（应该在同一事务中）
            roleService.assignRoleToUser(user.getPersonId(), "DEFAULT_ROLE");
            
            // 如果任一操作失败，整个事务应该回滚
        }).doesNotThrowAnyException();
    }
    
    @Test
    void testDataConstraints() {
        // 测试数据约束
        assertThatThrownBy(() -> {
            // 尝试创建重复邮箱的用户
            userService.createUser(createUserDTO("duplicate@email.com"));
            userService.createUser(createUserDTO("duplicate@email.com"));
        }).isInstanceOf(DataIntegrityViolationException.class);
    }
}
```

#### 4.2.2 外部接口集成测试

**测试目标：**
- 验证与Keycloak集成
- 测试外部API调用
- 验证数据同步机制

**测试用例设计：**

```java
@SpringBootTest
@MockServer
class ExternalIntegrationTest {
    
    @Autowired
    private KeycloakIntegrationService keycloakService;
    
    private MockServerClient mockServer;
    
    @Test
    void testKeycloakUserSync() {
        // 模拟Keycloak API响应
        mockServer
            .when(request()
                .withMethod("GET")
                .withPath("/auth/admin/realms/master/users"))
            .respond(response()
                .withStatusCode(200)
                .withHeader("Content-Type", "application/json")
                .withBody(createKeycloakUsersResponse()));
        
        // 执行同步
        SyncResult result = keycloakService.syncUsers();
        
        assertThat(result.getSuccessCount()).isGreaterThan(0);
        assertThat(result.getFailureCount()).isZero();
    }
    
    @Test
    void testKeycloakConnectionFailure() {
        // 模拟连接失败
        mockServer
            .when(request()
                .withPath("/auth/admin/realms/master/users"))
            .respond(response()
                .withStatusCode(500));
        
        assertThatThrownBy(() -> keycloakService.syncUsers())
            .isInstanceOf(IntegrationException.class);
    }
}
```

### 4.3 API接口测试

#### 4.3.1 RESTful API测试

**测试目标：**
- 验证API规范符合性
- 测试HTTP状态码正确性
- 验证请求响应格式

**自动化测试脚本：**

```bash
# 脚本名称：api_contract_test.sh
# 功能：API契约测试

echo "开始API契约测试..."

# 测试用户模块API
echo "测试用户API..."

# 创建用户
CREATE_RESPONSE=$(curl -s -X POST \
    -H "Content-Type: application/json" \
    -d '{
        "personName": "测试用户",
        "email": "test@example.com",
        "phoneNumber": "13800138000"
    }' \
    -w "%{http_code}" \
    http://localhost:8080/api/user/create)

HTTP_CODE=$(echo $CREATE_RESPONSE | tail -c 4)
RESPONSE_BODY=$(echo $CREATE_RESPONSE | head -c -4)

if [ "$HTTP_CODE" -eq 200 ]; then
    echo "✅ 用户创建API测试通过"
    USER_ID=$(echo $RESPONSE_BODY | jq -r '.data.personId')
else
    echo "❌ 用户创建API测试失败: HTTP $HTTP_CODE"
    echo "响应内容: $RESPONSE_BODY"
    exit 1
fi

# 查询用户
QUERY_RESPONSE=$(curl -s -w "%{http_code}" \
    http://localhost:8080/api/user/$USER_ID)

HTTP_CODE=$(echo $QUERY_RESPONSE | tail -c 4)

if [ "$HTTP_CODE" -eq 200 ]; then
    echo "✅ 用户查询API测试通过"
else
    echo "❌ 用户查询API测试失败: HTTP $HTTP_CODE"
    exit 1
fi

# 更新用户
UPDATE_RESPONSE=$(curl -s -X PUT \
    -H "Content-Type: application/json" \
    -d '{
        "personName": "更新后的用户名",
        "email": "updated@example.com"
    }' \
    -w "%{http_code}" \
    http://localhost:8080/api/user/$USER_ID)

HTTP_CODE=$(echo $UPDATE_RESPONSE | tail -c 4)

if [ "$HTTP_CODE" -eq 200 ]; then
    echo "✅ 用户更新API测试通过"
else
    echo "❌ 用户更新API测试失败: HTTP $HTTP_CODE"
    exit 1
fi

# 删除用户
DELETE_RESPONSE=$(curl -s -X DELETE \
    -w "%{http_code}" \
    http://localhost:8080/api/user/$USER_ID)

HTTP_CODE=$(echo $DELETE_RESPONSE | tail -c 4)

if [ "$HTTP_CODE" -eq 200 ]; then
    echo "✅ 用户删除API测试通过"
else
    echo "❌ 用户删除API测试失败: HTTP $HTTP_CODE"
    exit 1
fi

echo "用户API测试完成"

# 测试权限模块API
echo "测试权限API..."

# 类似的测试逻辑...

echo "API契约测试完成"
```

#### 4.3.2 性能基准测试

**测试目标：**
- 建立性能基准线
- 验证接口响应时间
- 测试并发处理能力

**自动化测试脚本：**

```bash
# 脚本名称：api_performance_baseline.sh
# 功能：建立API性能基准

echo "开始API性能基准测试..."

# 安装必要工具
if ! command -v wrk &> /dev/null; then
    echo "安装wrk压测工具..."
    # 根据系统安装wrk
fi

# 准备测试数据
echo "准备测试数据..."
curl -s -X POST \
    -H "Content-Type: application/json" \
    -d '{"personName": "压测用户", "email": "load@test.com"}' \
    http://localhost:8080/api/user/create > /dev/null

# 单接口性能测试
echo "测试用户查询接口性能..."
wrk -t4 -c10 -d30s --latency http://localhost:8080/api/user/list > user_query_result.txt

# 解析结果
REQUESTS_PER_SEC=$(grep "Requests/sec:" user_query_result.txt | awk '{print $2}')
AVG_LATENCY=$(grep "Latency" user_query_result.txt | awk '{print $2}')

echo "用户查询接口性能："
echo "  QPS: $REQUESTS_PER_SEC"
echo "  平均延迟: $AVG_LATENCY"

# 设置性能基准
MIN_QPS=100
MAX_LATENCY_MS=500

QPS_VALUE=$(echo $REQUESTS_PER_SEC | cut -d'.' -f1)
LATENCY_VALUE=$(echo $AVG_LATENCY | sed 's/ms//')

if [ "$QPS_VALUE" -ge "$MIN_QPS" ]; then
    echo "✅ QPS达标 ($QPS_VALUE >= $MIN_QPS)"
else
    echo "❌ QPS不达标 ($QPS_VALUE < $MIN_QPS)"
fi

if (( $(echo "$LATENCY_VALUE <= $MAX_LATENCY_MS" | bc -l) )); then
    echo "✅ 延迟达标 (${LATENCY_VALUE}ms <= ${MAX_LATENCY_MS}ms)"
else
    echo "❌ 延迟超标 (${LATENCY_VALUE}ms > ${MAX_LATENCY_MS}ms)"
fi

echo "API性能基准测试完成"
```

## 第五阶段：测试文档与工具（第11-12周）

### 5.1 测试文档编写

#### 5.1.1 测试用例文档模板

**模板结构：**

```markdown
# 测试用例文档

## 基本信息
- 测试用例ID: TC_USER_001
- 测试模块: 用户管理
- 测试功能: 用户创建
- 优先级: P1
- 创建日期: 2023-09-13
- 创建人: 测试工程师

## 测试目标
验证用户创建功能的正确性，包括数据验证、业务规则和异常处理。

## 前置条件
1. 系统已启动
2. 数据库连接正常
3. 具有用户管理权限

## 测试步骤
1. 发送用户创建请求
2. 验证请求参数
3. 执行用户创建逻辑
4. 检查返回结果

## 测试数据
```json
{
    "personName": "张三",
    "email": "zhangsan@example.com",
    "phoneNumber": "13800138000",
    "deptId": "dept123"
}
```

## 期望结果
- HTTP状态码: 200
- 返回用户ID
- 数据库中创建用户记录
- 触发用户创建事件

## 实际结果
（待填写）

## 测试结论
（待填写）
```

#### 5.1.2 缺陷报告模板

**模板结构：**

```markdown
# 缺陷报告

## 基本信息
- 缺陷ID: BUG_001
- 发现日期: 2023-09-13
- 报告人: 测试工程师
- 严重程度: 严重
- 优先级: P1
- 状态: 新建

## 缺陷描述
在用户创建过程中，当邮箱格式无效时，系统返回500错误而不是400错误。

## 复现步骤
1. 访问用户创建接口
2. 传入无效邮箱格式 "invalid-email"
3. 提交请求

## 期望结果
- 返回HTTP 400错误
- 错误消息明确指出邮箱格式无效

## 实际结果
- 返回HTTP 500错误
- 错误消息为"内部服务器错误"

## 环境信息
- 操作系统: Windows 10
- JDK版本: 17
- 应用版本: 1.0.0-SNAPSHOT

## 附件
- 错误日志文件
- 请求响应截图
```

### 5.2 测试工具开发

#### 5.2.1 测试数据生成工具

**工具功能：**
- 自动生成测试用户数据
- 创建测试组织架构
- 生成权限测试数据

**实现示例：**

```java
@Component
public class TestDataGenerator {
    
    public List<UserCreateDTO> generateUsers(int count) {
        List<UserCreateDTO> users = new ArrayList<>();
        
        for (int i = 1; i <= count; i++) {
            UserCreateDTO user = new UserCreateDTO();
            user.setPersonName("测试用户" + i);
            user.setEmail("user" + i + "@test.com");
            user.setPhoneNumber("1380013800" + String.format("%02d", i % 100));
            user.setGender(i % 2 == 0 ? "男" : "女");
            user.setBirthDate(LocalDate.of(1990 + (i % 30), (i % 12) + 1, (i % 28) + 1));
            
            users.add(user);
        }
        
        return users;
    }
    
    public List<DepartmentCreateDTO> generateDepartments(int count) {
        List<DepartmentCreateDTO> departments = new ArrayList<>();
        
        for (int i = 1; i <= count; i++) {
            DepartmentCreateDTO dept = new DepartmentCreateDTO();
            dept.setDeptName("测试部门" + i);
            dept.setDeptCode("TEST_DEPT_" + i);
            dept.setDeptType(DepartmentType.BUSINESS);
            
            departments.add(dept);
        }
        
        return departments;
    }
}
```

#### 5.2.2 测试执行脚本

**全量测试脚本：**

```bash
#!/bin/bash
# 脚本名称：run_all_tests.sh
# 功能：执行所有测试套件

set -e

echo "======================================"
echo "PS-BE 模块重构测试套件"
echo "======================================"

# 检查环境
echo "检查测试环境..."
if ! command -v java &> /dev/null; then
    echo "❌ Java环境未安装"
    exit 1
fi

if ! command -v mvn &> /dev/null; then
    echo "❌ Maven未安装"
    exit 1
fi

# 启动应用
echo "启动测试应用..."
mvn spring-boot:start -Dspring-boot.run.profiles=test &
APP_PID=$!

# 等待应用启动
echo "等待应用启动..."
for i in {1..30}; do
    if curl -s http://localhost:8080/actuator/health > /dev/null; then
        echo "✅ 应用启动成功"
        break
    fi
    sleep 2
done

# 执行单元测试
echo "执行单元测试..."
mvn test -Dtest="*UnitTest"

# 执行集成测试
echo "执行集成测试..."
mvn test -Dtest="*IntegrationTest"

# 执行API测试
echo "执行API测试..."
./api_contract_test.sh

# 执行性能基准测试
echo "执行性能基准测试..."
./api_performance_baseline.sh

# 生成测试报告
echo "生成测试报告..."
mvn jacoco:report

# 清理
echo "清理测试环境..."
kill $APP_PID

echo "======================================"
echo "测试完成！"
echo "测试报告位置: target/site/jacoco/index.html"
echo "======================================"
```

#### 5.2.3 持续集成配置

**Jenkins Pipeline配置：**

```groovy
pipeline {
    agent any
    
    stages {
        stage('Checkout') {
            steps {
                git branch: 'feature/module-refactor', url: 'https://github.com/company/ps-be.git'
            }
        }
        
        stage('Build') {
            steps {
                sh 'mvn clean compile'
            }
        }
        
        stage('Unit Tests') {
            steps {
                sh 'mvn test -Dtest="*UnitTest"'
            }
            post {
                always {
                    junit 'target/surefire-reports/*.xml'
                }
            }
        }
        
        stage('Integration Tests') {
            steps {
                sh 'mvn test -Dtest="*IntegrationTest"'
            }
        }
        
        stage('API Tests') {
            steps {
                sh './scripts/api_contract_test.sh'
            }
        }
        
        stage('Code Coverage') {
            steps {
                sh 'mvn jacoco:report'
                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    reportDir: 'target/site/jacoco',
                    reportFiles: 'index.html',
                    reportName: 'Coverage Report'
                ])
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        success {
            echo '✅ 所有测试通过'
        }
        failure {
            echo '❌ 测试失败，请检查日志'
        }
    }
}
```

## 测试验收标准

### 功能验收标准

1. **功能完整性**
   - 所有现有API功能正常
   - 新增功能按需求实现
   - 业务流程端到端可用

2. **数据一致性**
   - 新旧接口操作同一数据
   - 数据迁移无丢失
   - 关联关系保持正确

3. **性能基准**
   - 重构后性能不降级
   - 关键接口响应时间 < 500ms
   - 并发处理能力满足要求

### 质量验收标准

1. **测试覆盖率**
   - 单元测试覆盖率 > 80%
   - 集成测试覆盖主要流程
   - API测试覆盖所有接口

2. **代码质量**
   - 无严重代码质量问题
   - 循环依赖清零
   - 代码复杂度控制在合理范围

3. **稳定性**
   - 连续运行24小时无异常
   - 内存泄漏检查通过
   - 错误处理机制完善

## 总结

本测试指南为PS-BE模块重构提供了完整的测试策略和实施方案。通过分阶段、分层次的测试方法，确保重构过程中功能稳定性和代码质量。

**测试价值体现：**
- 🛡️ **风险控制**：通过全面测试降低重构风险
- 🔍 **质量保证**：确保代码质量和功能完整性  
- 🚀 **持续集成**：支持自动化测试和持续交付
- 📊 **数据驱动**：通过测试数据指导重构决策
- 🔄 **回归验证**：确保重构不破坏现有功能